<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>Tarihe Göre PPTX Aç</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; max-width:700px; margin:40px auto; line-height:1.45; }
    label, select, input, button { display:block; margin:8px 0; }
    .info { color:#444; margin-top:12px; }
    .error { color: #900; margin-top:12px; }
  </style>
</head>
<body>
  <h1>Tarihe Göre .pptx Aç</h1>

  <!-- Tarih seçimi -->
  <label for="date">Tarih seçin:</label>
  <input id="date" type="date" />

  <!-- Hazır adlandırma şablonları -->
  <label for="pattern">Adlandırma şablonu (tahmini):</label>
  <select id="pattern">
    <option value="YYYY-MM-DD">YYYY-MM-DD (ör: 2025-11-19)</option>
    <option value="YYYYMMDD">YYYYMMDD (ör: 20251119)</option>
    <option value="DD-MM-YYYY">DD-MM-YYYY (ör: 19-11-2025)</option>
    <option value="DDMMYYYY">DDMMYYYY (ör: 19112025)</option>
    <option value="prefix_DATE">prefix_DATE (ör: sunum_2025-11-19)</option>
    <option value="DATE_suffix">DATE_suffix (ör: 2025-11-19_sunum)</option>
    <option value="try-many" selected>Birden fazla olası formata dene (önerilen)</option>
  </select>

  <label for="prefix">(İsteğe bağlı) Özel prefix/suffix (boş bırakılabilir):</label>
  <input id="prefix" placeholder="örn: sunum_, rapor-" />

  <div>
    <button id="go">Git / Dosyayı Aç</button>
  </div>

  <div class="info" id="status">Durum: beklemede.</div>

<script>
(async function(){
  const dateInput = document.getElementById('date');
  const patternSel = document.getElementById('pattern');
  const prefixInput = document.getElementById('prefix');
  const status = document.getElementById('status');
  const goBtn = document.getElementById('go');

  // Yardımcı: tarih nesnesinden farklı string formatları üretir
  function formatsFromDate(d) {
    const y = d.getFullYear().toString();
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return {
      'YYYY-MM-DD': `${y}-${mm}-${dd}`,
      'YYYYMMDD': `${y}${mm}${dd}`,
      'DD-MM-YYYY': `${dd}-${mm}-${y}`,
      'DDMMYYYY': `${dd}${mm}${y}`,
    };
  }

  // Bir URL'in varlığını HEAD isteğiyle kontrol et (CORS / sunucu izinlerine bağlı).
  async function existsUrl(url) {
    try {
      // HEAD isteği sunucu tarafından kabul edilmeyebilir; o zaman GET ile küçük isteğe düşülebilir.
      const res = await fetch(url, { method: 'HEAD' });
      return res.ok;
    } catch (e) {
      console.warn('Fetch head failed for', url, e);
      // fetch hata verirse (CORS veya file://), false dön.
      return false;
    }
  }

  // Belirtilen dosyaya yönlendir
  function gotoFile(url) {
    status.textContent = 'Bulundu: ' + url + ' — yönlendiriliyorsunuz...';
    window.location.href = url;
  }

  async function tryOpenForDate(dateStr) {
    // dateStr ISO format yyyy-mm-dd
    const d = new Date(dateStr);
    if (isNaN(d)) {
      status.innerHTML = '<span class="error">Geçersiz tarih.</span>';
      return;
    }
    status.textContent = 'Aranıyor...';

    const formats = formatsFromDate(d);
    const prefix = prefixInput.value || '';
    const pattern = patternSel.value;

    // adayı oluştur
    let candidates = [];

    if (pattern === 'try-many') {
      // makul aday listesi: direkt, prefix+date, date+suffix, farklı formatlar
      Object.values(formats).forEach(f => {
        candidates.push(`${f}.pptx`);
        candidates.push(`${prefix}${f}.pptx`);
        candidates.push(`${f}${prefix}.pptx`);
        candidates.push(`${prefix}${f}_sunum.pptx`);
        candidates.push(`sunum_${f}.pptx`);
        candidates.push(`presentation-${f}.pptx`);
      });
    } else if (pattern === 'prefix_DATE') {
      const f = formats['YYYY-MM-DD'];
      candidates.push(`${prefix}${f}.pptx`);
    } else if (pattern === 'DATE_suffix') {
      const f = formats['YYYY-MM-DD'];
      candidates.push(`${f}${prefix}.pptx`);
    } else {
      // belirli format
      const f = formats[pattern] || formats['YYYY-MM-DD'];
      candidates.push(`${f}.pptx`);
      candidates.push(`${prefix}${f}.pptx`);
      candidates.push(`${f}${prefix}.pptx`);
    }

    // Aynı klasörde olduklarını varsayıyoruz -> relative path: './<dosya>'
    // Tek tek deneyip HEAD isteği başarılıysa yönlendir.
    for (const name of candidates) {
      const url = './' + encodeURIComponent(name);
      status.textContent = `Deneniyor: ${name}`;
      // fetch varlığı kontrol eder. Not: local file:// sayfasında çalışmayabilir.
      const ok = await existsUrl(url);
      if (ok) {
        gotoFile(url);
        return;
      }
    }

    // Eğer HEAD ile bulunamadıysa son çare: doğrudan ilk adayı dene (sunucu bazı HEAD isteğini reddediyor olabilir)
    const fallback = './' + encodeURIComponent(candidates[0] || 'unknown.pptx');
    status.innerHTML = 'Dosya bulunamadı (HEAD check). Sonuç bulunamadıysa, ilk adayla doğrudan yönlendiriliyor: ' + fallback;
    // Yönlendirmeyi yorum satırı dışına çıkarırsanız doğrudan deneyecektir:
    // window.location.href = fallback;
  }

  goBtn.addEventListener('click', (e) => {
    e.preventDefault();
    if (!dateInput.value) {
      status.innerHTML = '<span class="error">Lütfen bir tarih seçin.</span>';
      return;
    }
    tryOpenForDate(dateInput.value);
  });

})();
</script>
</body>
</html>
